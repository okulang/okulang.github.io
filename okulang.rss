<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     >
  <channel>
    <title>Okulang</title>
    <description>Naturalistic conlangs a priori.</description>
    <link>http://okulang.github.io</link>
    <language>en-us</language>
    <atom:link href="http://okulang.github.com/okulang.rss" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Complanging: Languages for Computers</title>
      <link>http://okulang.github.io/complanging.html</link>
      <pubDate>Wed, 09 Sep 2015 16:18:12 +0000</pubDate>
      <description><![CDATA[The common wisdom is that computer languages are not like human lanuages. Period.
Well, although the computer science master's thesis was ostensibly on "first-class control", what it really did was indulge my love of constructing languages, and it even cited a linguistics paper.
Since I've had deep experience in the construction of both human and computer languages, I may as well look at the difference.
It turns out there are more connections than I had at first thought.
]]></description>
      <content:encoded><![CDATA[
        
        <p>
There are definitely differences between languages for humans and for computers.
With human conlangs, its not too hard to make a good language, but it's often very difficult to describe what's going on.
When complanging, it's fairly easy to give a description, but it's very difficult to make a good language.
This is about where the differences end and the similarities begin.
</p>

<p>
Let me breifly describe the process by which a computer language is constructed:
<ol>
  <li>Have a goal (e.g. I want to model GPU parallelism).</li>
  <li>Create a syntax (this is roughly the equivalent of a phonology).</li>
  <li>Create a semantics (answers questions like: "what happens when I say this?" and "are these programs the same?")</li>
  <li>Optionally make up primitives (each primitive is roughly like an entry in a lexicon)</li>
  <li>Show off (e.g. write cool programs, prove the language's type system is sound)</li>
  <li>Implement the language (i.e. teach computers to use it)</li>
</ol>
As you can see, complanging follows essentially the same process as humanlanging.
On the other hand, perhaps you brain has been stimulated into seeing some other apparent differences.
</p>

<p>
For example, computer languages are designed to be small, clear, elegant, regular, whereas human languages can be designed for any reason.
In fact, there's a class of so-called esoteric languages which are designed primarily to be humorous, unclear, or just plain weird.
The funniest conlangs I've seen are computer languages, and so are the most complicated.
</p>

<p>
You might think that the lack of phonology in computer languages makes them qualitatively different.
Actually, human languages include sign languages and even a gripping language, so human languages can lack phonology.
Though I don't know of any, I could easily imagine a sound-based computer language;
in fact, there's already a computer language designed to look like paintings by Piet Mondrian.
</p>

<p>
It's true that there are some trends that differ.
Most computer languages are a posteriori englangs designed to be small, clear, and simple.
That's where the work happens to be.
Of course, a difference in these trends is a difference in the community, not in the nature of the languages.
</p>

<p>
Just to drive the point home, let's consider one last possible difference.
Perhaps it's that computers don't work with computer languages directly, they just follow the instructions.
Actually, optimizing compilers will analyze the meaning of your code and rewrite it to be more efficient, while keeping the meaning the same.
Virus scanners will read through code to find malware, and then censor it.
There are even a class of programs that write other programs from scratch: it's a technique called genetic programming, and it can produce amazing results.
There you have it: computers working with computer languages not just by running them, but also by reading, writing, and, in a sense, understanding the source code directly.
</p>

<p>
Complanging and humanlanging share the same creative process, the same mechanisms, the same range of expression, even the same theory sometimes.
The two might even be as "far" apart as fiction and non-fiction; so what? I'm still reading books.
Yet, complangs seem to get a bad rap among conlangers.
I'm guilty of this myself: you don't see my complangs posted here, not yet anyway.
The more I think about it, the less satisfied I am with this state of affairs.
If we stop repeating the common "wisdom" that computer languages are not linguistic, we might just find ourselves with a richer community.
</p>

<p>
As computer languages get better, they slowly start to seem less like recipies and more like communication to me.
Perhaps conlangers have something to contribute here to advance the state of the art in complanging.
Sure, it would require learning the jargon of programming languages, but you all learned linguistics, so it's not all that unrealistic that someone might come along and give it a shot.
Or perhaps it would be more fun to build a computer-like language for humans; what could that be like?
Heh, well it would undoubtedly give the Cybermen better catchphrases!
</p>
      ]]></content:encoded>
      <guid>http://okulang.github.io/complanging.html</guid>
    </item>
    <item>
      <title>Valyrian Spice</title>
      <link>http://okulang.github.io/valyrian-spice.html</link>
      <pubDate>Mon, 07 Sep 2015 16:29:05 +0000</pubDate>
      <description><![CDATA[]]></description>
      <content:encoded><![CDATA[
        
        <p>
I was just looking at DJP's haiku contest this year, since I just now found his blog.
Yes, yes, you're allowed to yell at me about not knowing anything about the conlang community (conmunity?)...
if you can find the comment box.
Nya-nya!
</p>

<p>
Anyway, if I'm to be perfectly honest, I wasn't very happy when I first heard Valyrian.
My first impression was that it was, um, chewing the scenery maybe?; it's hard to describe.
In any case, I've now seen it written, and I like it more that way.
In fact, I may just look up some materials and get some familiarity.
Oddly, even though I do really like the sound of Dothraki or Na'vi, I haven't bothered to introduce myself to them really.
How could Valyrian jump to the top spot on my reading list with such a poor first impression, I hear you not asking?
</p>

<p>
Well, as long-time followers won't know, I've recently (this summer) become a bit enamored of Old Norse and Ukrainian.
I'd done some initial work for a language based on those sounds under the names Myrkolð /myrkɒlθ/ and Anj /ɑnʲ/, but just didn't enjoy them; something was missing.
I have a sneaking suspicion that Valyrian is the secret ingredient.
</p>

<p>
I'm looking forward to ressurrecting the language, but first things first: I have to get Iskki Leke'sou [isːki lɛgɛʔsəʊ̜] working before I pollute my brain with any other cool ideas.
</p>
      ]]></content:encoded>
      <guid>http://okulang.github.io/valyrian-spice.html</guid>
    </item>
  </channel>
</rss>